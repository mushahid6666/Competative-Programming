import collections
class Solution(object):
    def minMalwareSpread(self, graph, initial):
        # 1. Color each component.
        # colors[node] = the color of this node.

        N = len(graph)
        colors = {}
        c = 0

        def dfs(node, color):
            colors[node] = color
            for nei, adj in enumerate(graph[node]):
                if adj and nei not in colors:
                    dfs(nei, color)

        for node in xrange(N):
            if node not in colors:
                dfs(node, c)
                c += 1

        # 2. Size of each color.
        # size[color] = number of occurrences of this color.
        print  colors.values()
        size = collections.Counter(colors.values())
        print  size
        # 3. Find unique colors.
        color_count = collections.Counter()
        for node in initial:
            color_count[colors[node]] += 1
        print color_count
        # 4. Answer
        ans = float('inf')

        for x in initial:
            c = colors[x]
            if color_count[c] == 1:
                if ans == float('inf'):
                    ans = x
                elif size[c] > size[colors[ans]]:
                    ans = x
                elif size[c] == size[colors[ans]] and x < ans:
                    ans = x

        return ans if ans < float('inf') else min(initial)
obj = Solution()
graph = [[1,0,1,1,0,0],
         [0,1,1,1,0,0],
         [1,1,1,0,1,0],
         [1,1,0,1,1,1],
         [0,0,1,1,1,0],
         [0,0,0,1,0,1]]
initial = [1,2,3]
# print obj.minMalwareSpread(graph, initial)
# graph = [[1,1,0],[1,1,0],[0,0,1]]
# initial = [0,1]
# print obj.minMalwareSpread(graph, initial)
# graph = [[1,1,0],[1,1,0],[0,0,1]]
# initial = [0,1]
# print obj.minMalwareSpread(graph, initial)
# graph = [[1,0,0],[0,1,0],[0,0,1]]
# initial = [0,2]
# print obj.minMalwareSpread(graph, initial)
# graph = [[1,1,1],[1,1,1],[1,1,1]]
# initial = [1,2]
# print obj.minMalwareSpread(graph, initial)
graph = [[1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0],[0,1,1,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0,0,0],[1,0,0,0,1,0,0,0,0,0],[0,0,1,0,0,1,0,0,0,0],[0,0,0,0,0,0,1,0,0,1],[0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,1,0,0,1]]
initial = [1,3,0]
print obj.minMalwareSpread(graph, initial)

{
# class Solution(object):
#
#     def compare(self, a, b):
#         if a[1] < b[1]:
#             return 1
#         elif a[1] > b[1]:
#             return -1
#         else:
#             if a[0] < b[0]:
#                 return -1
#             else:
#                 return 1
#     def minMalwareSpread(self, graph, initial):
#         """
#         :type graph: List[List[int]]
#         :type initial: List[int]
#         :rtype: int
#         """
#         nodes_infected = dict()
#         for node in initial:
#             nodes_infected[node] = set()
#         unique_nodes_infected_map = dict()
#         for node in initial:
#             unique_nodes_infected_map[node] = 0
#             for i in range(len(graph)):
#                 if graph[node][i] == 1:
#                     nodes_infected[node].add(i)
#         # print nodes_infected.items()
#         # print nodes_infected.values()
#         for node_malware in nodes_infected.keys():
#             nodes_infected_set = nodes_infected[node_malware]
#             for node_malwared in nodes_infected_set:
#                 # print  "affecte_node:", node,
#                 unique= True
#                 for other_affected_node in nodes_infected:
#                     # print  "other_affected_node:", other_affected_node,
#                     if other_affected_node!= node_malware and node_malwared in nodes_infected[other_affected_node]:
#                         unique = False
#                         break
#                 if unique == True:
#                     unique_nodes_infected_map[node_malware] += 1
#
#                 # print "\n"
#         unique_nodes_infected_map =  unique_nodes_infected_map.items()
#         # print unique_nodes_infected_map
#         unique_nodes_infected_map.sort(self.compare)
#         print unique_nodes_infected_map
#         return unique_nodes_infected_map[0][0]
}
